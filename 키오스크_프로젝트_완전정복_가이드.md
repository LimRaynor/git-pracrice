# 🍔 키오스크 프로젝트 완전정복 가이드

> **프로젝트 요약:** 패스트푸드 무인 주문 키오스크 (Vue.js 프론트엔드 + JSON Server 백엔드)
> 메뉴 선택 → 결제 → 주문완료까지의 전체 플로우를 가진 웹 애플리케이션

---

## 📌 1장. 먼저 알아야 할 것: 우리 프로젝트의 구조

### 1-1. 전체 기술 스택

```
┌─────────────────────────────────────────────────┐
│              사용자 (브라우저)                      │
│    키오스크 화면을 보고 터치/클릭하는 사람             │
└──────────────────────┬──────────────────────────┘
                       │ 화면에 보이는 것 = Vue.js
                       ▼
┌─────────────────────────────────────────────────┐
│         프론트엔드 (Vue.js + Vite)                │
│  - 화면(UI)을 그려주는 역할                         │
│  - 사용자의 클릭/입력을 받아서 처리                   │
│  - 서버에 데이터를 요청하거나 보냄                    │
└──────────────────────┬──────────────────────────┘
                       │ HTTP 요청 (axios 라이브러리 사용)
                       │ 예: GET /menuItems, POST /orders
                       ▼
┌─────────────────────────────────────────────────┐
│         백엔드 (JSON Server, port 3000)           │
│  - db.json 파일을 데이터베이스처럼 사용              │
│  - REST API를 자동으로 만들어줌                     │
│  - 실제 Spring Boot는 아니지만 동일한 역할           │
└──────────────────────┬──────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────┐
│         데이터베이스 (db.json 파일)                 │
│  - users, categories, menuItems, orders 등       │
│  - JSON 형태로 데이터 저장                          │
└─────────────────────────────────────────────────┘
```

### 1-2. "클라이언트→서버→컨트롤러→서비스→레파지토리→DB" 와의 관계

당신이 배운 이 흐름은 **Spring Boot(자바) 백엔드**의 흐름이에요. 이 프로젝트는 JSON Server를 사용하기 때문에 컨트롤러/서비스/레파지토리가 자동으로 처리됩니다. 하지만 **개념은 동일**해요:

```
당신이 배운 흐름:
클라이언트 → 서버 → 컨트롤러 → 서비스 → 레파지토리 → DB

이 프로젝트에서의 대응:
Vue 화면  → axios → JSON Server(컨트롤러+서비스+레파지토리 자동) → db.json(DB)
```

| 당신이 배운 개념 | 역할 | 이 프로젝트에서는? |
|---|---|---|
| **클라이언트** | 사용자가 보는 화면 | `src/views/` 폴더의 `.vue` 파일들 |
| **서버로 요청** | 화면에서 서버로 데이터 요청 | `src/services/api.js` (axios 사용) |
| **컨트롤러** | 요청을 받아서 어떤 서비스를 호출할지 결정 | JSON Server가 자동 처리 |
| **서비스** | 실제 비즈니스 로직 처리 | JSON Server가 자동 처리 |
| **레파지토리** | DB에서 데이터 꺼내오기/저장하기 | JSON Server가 자동 처리 |
| **DB** | 데이터 저장소 | `src/data/db.json` 파일 |

---

## 📌 2장. 왜 요청이 이동하는가? (핵심 개념)

### 2-1. 비유로 이해하기: 레스토랑

```
🧑 손님(클라이언트/Vue 화면)
   "치즈버거 주세요!" (버튼 클릭)
        │
        ▼
🛎️ 카운터 직원(컨트롤러)
   "치즈버거 주문이요~ 주방에 전달합니다"
   → 어떤 요청인지 확인하고, 적절한 곳에 전달하는 역할
        │
        ▼
👨‍🍳 주방장(서비스)
   "치즈버거를 만들려면 빵, 패티, 치즈가 필요하네"
   → 실제 일을 처리하는 역할 (비즈니스 로직)
        │
        ▼
📦 창고 담당자(레파지토리)
   "빵 1개, 패티 1개, 치즈 1장 꺼내왔습니다"
   → 데이터를 꺼내오거나 저장하는 역할
        │
        ▼
🏪 창고(DB)
   실제 재료(데이터)가 보관되어 있는 곳
```

### 2-2. 왜 이렇게 나눠야 할까?

**"그냥 화면에서 바로 DB에 접근하면 안 돼?"** 라고 생각할 수 있어요.

안 되는 이유를 실생활로 비유하면:

**보안 문제**: 손님이 직접 주방에 들어가면? → 식재료를 마음대로 가져갈 수 있음 → 브라우저에서 DB에 직접 접근하면 해커가 데이터를 마음대로 조작 가능

**역할 분리**: 카운터 직원이 요리도 하고, 재료 관리도 하면? → 너무 복잡해지고 한 명이 아프면 전체가 마비 → 코드도 마찬가지. 각각의 역할을 분리해야 유지보수가 쉬움

**검증**: 손님이 "공짜 버거 주세요"라고 하면? → 카운터에서 거부해야 함 → 서버에서 요청을 검증하지 않으면 악의적인 요청도 통과됨

---

## 📌 3장. 프로젝트의 파일 구조 해설

```
vue-team-project/
├── src/
│   ├── views/                    ← 📺 화면(페이지)들
│   │   ├── MainPage.vue          ← 첫 화면 (매장식사/포장 선택)
│   │   ├── OrderPage.vue         ← 메뉴 선택 화면
│   │   ├── PaymentMethodPage.vue ← 결제수단 선택 화면
│   │   ├── PaymentConfirmPage.vue← 결제 확인 화면
│   │   ├── PaymentProcessView.vue← 결제 처리 중 화면
│   │   ├── PaymentFailView.vue   ← 결제 실패 화면
│   │   ├── AdminLoginPage.vue    ← 관리자 로그인
│   │   ├── AdminDashboard.vue    ← 관리자 대시보드
│   │   ├── AdminMenuManagement.vue← 관리자 메뉴 관리
│   │   └── AdminSalesStats.vue   ← 관리자 매출 통계
│   │
│   ├── components/               ← 🧩 재사용 가능한 부품들
│   │   ├── MenuInfoModal.vue     ← 메뉴 상세 팝업
│   │   ├── KeypadModal.vue       ← 숫자 키패드 팝업
│   │   ├── OrderCompletionModal.vue ← 주문완료 팝업
│   │   ├── MessageModal.vue      ← 알림 메시지 팝업
│   │   ├── LanguageSwitcher.vue  ← 언어 변경 버튼
│   │   └── Screensaver.vue       ← 화면보호기
│   │
│   ├── services/                 ← 📡 서버 통신 담당
│   │   ├── api.js                ← API 함수 모음
│   │   └── axios.js              ← axios 기본 설정
│   │
│   ├── stores/                   ← 🗄️ 상태(데이터) 관리
│   │   └── orderStore.js         ← 주문 데이터 저장소
│   │
│   ├── router/                   ← 🗺️ 페이지 이동 관리
│   │   └── index.js              ← URL과 페이지 연결
│   │
│   ├── data/                     ← 💾 데이터베이스
│   │   └── db.json               ← 모든 데이터 저장
│   │
│   ├── locales/                  ← 🌐 다국어 지원
│   │   ├── i18n.js
│   │   └── translations.js
│   │
│   ├── App.vue                   ← 앱의 최상위 컴포넌트
│   └── main.js                   ← 앱 시작점
│
└── index.html                    ← 브라우저가 처음 읽는 파일
```

---

## 📌 4장. 주문 플로우 완전 해부 (가장 중요!)

실제 사용자가 키오스크를 사용하는 순서를 따라가면서 코드가 어떻게 동작하는지 살펴볼게요.

### 🔵 STEP 1: 메인 화면 (MainPage.vue)

**사용자 행동:** 키오스크 앞에 서서 "매장식사" 또는 "포장" 버튼을 누름

```javascript
// MainPage.vue에서 일어나는 일

// 1. 사용자가 "매장식사" 버튼을 클릭하면
<button @click="selectDiningOption('forHere')">
  🍽️ 매장식사
</button>

// 2. 이 함수가 실행됨
const selectDiningOption = (option) => {
  router.push({name:'Order'})  // 주문 페이지로 이동!
}
```

**코드 해석:**
- `@click="selectDiningOption('forHere')"` → 버튼을 클릭하면 `selectDiningOption` 함수를 실행해라
- `router.push({name:'Order'})` → Order라는 이름의 페이지로 이동해라
- `router`는 **네비게이터** 같은 것. "이 URL로 가줘"라고 말하면 해당 화면을 보여줌

**router/index.js에서의 연결:**
```javascript
{
  path: '/order',        // URL이 /order 일 때
  name: 'Order',         // 이름은 'Order'
  component: () => import('@/views/OrderPage.vue')  // OrderPage.vue를 보여줘
}
```

---

### 🔵 STEP 2: 메뉴 선택 화면 (OrderPage.vue)

**사용자 행동:** 카테고리(피자, 햄버거 등)를 고르고, 메뉴를 선택하고, 장바구니에 담음

```javascript
// OrderPage.vue에서 일어나는 일

// ===== [1단계] 화면이 열리자마자 서버에서 데이터를 가져옴 =====
onMounted(async () => {
  // Promise.all = "이 3개를 동시에 요청해서 다 오면 진행해"
  const [categoriesData, menuItemsData, combinationsData] = await Promise.all([
    api.getCategories(),     // 카테고리 목록 요청 (피자, 햄버거, 음료...)
    api.getMenuItems(),      // 전체 메뉴 목록 요청 (치즈버거 5000원...)
    api.getCombinations()    // 세트 메뉴 목록 요청
  ])
  categories.value = categoriesData     // 받은 데이터를 화면에 저장
  menuItems.value = menuItemsData
  combinations.value = combinationsData
})
```

**여기서 일어나는 통신 흐름:**
```
[Vue 화면]                    [api.js]                  [JSON Server]        [db.json]
    │                            │                           │                   │
    │ api.getMenuItems() 호출    │                           │                   │
    │──────────────────────────>│                           │                   │
    │                            │ GET /menuItems 요청       │                   │
    │                            │─────────────────────────>│                   │
    │                            │                           │ db.json에서       │
    │                            │                           │ menuItems 읽기    │
    │                            │                           │──────────────────>│
    │                            │                           │<──────────────────│
    │                            │   JSON 데이터 응답         │   데이터 반환      │
    │                            │<─────────────────────────│                   │
    │   메뉴 목록 반환             │                           │                   │
    │<──────────────────────────│                           │                   │
    │                            │                           │                   │
    │ 화면에 메뉴 카드 표시        │                           │                   │
```

**api.js의 해당 코드:**
```javascript
async getMenuItems() {
  return axiosInstance.get('/menuItems')
  // axiosInstance.get('/menuItems')는 다음과 같은 뜻:
  // "http://localhost:3000/menuItems 주소로 GET 요청을 보내줘"
  // GET = "데이터를 달라"는 의미의 HTTP 메서드
}
```

**axios.js의 역할:**
```javascript
const axiosInstance = axios.create({
  baseURL: 'http://localhost:3000',  // 모든 요청 앞에 이 주소가 붙음
  timeout: 10000,                     // 10초 안에 응답 없으면 에러
  headers: {
    'Content-Type': 'application/json'  // "나는 JSON 형태로 데이터를 주고받겠다"
  }
})

// Response Interceptor (응답 가로채기)
axiosInstance.interceptors.response.use(
  (response) => response.data,  // 응답이 오면 .data 부분만 꺼내서 반환
  // axios 응답 형태: { status: 200, data: [...], headers: {...} }
  // response.data만 반환하면: [...] ← 우리가 필요한 실제 데이터만 가져옴
)
```

```javascript
// ===== [2단계] 사용자가 메뉴를 클릭하면 =====
const openMenuModal = (menu) => {
  if (menu.isSoldOut) return          // 품절이면 아무것도 안 함
  if (menu.stock <= 0) return          // 재고가 0이면 아무것도 안 함
  selectedMenu.value = menu            // 선택한 메뉴를 저장
  isModalOpen.value = true             // 상세 팝업을 열어!
}

// ===== [3단계] 장바구니에 담기 (Store 사용) =====
// MenuInfoModal에서 "담기" 버튼을 누르면 orderStore에 추가됨
orderStore.addItem({
  id: menu.id,
  name: menu.name,
  price: menu.price,
  quantity: 1
})
```

**orderStore.js의 addItem 동작:**
```javascript
addItem(item) {
  // 이미 같은 메뉴가 장바구니에 있는지 확인
  const existingIndex = this.orderList.findIndex(i => i.id === item.id)
  
  if (existingIndex >= 0) {
    // 있으면 → 수량만 +1
    this.orderList[existingIndex].quantity += item.quantity
  } else {
    // 없으면 → 새로 추가
    this.orderList.push({ ...item })
  }
}
```

**Store(Pinia)란?**
```
Store = 여러 화면이 공유하는 데이터 보관함

예시:
  OrderPage에서 장바구니에 "치즈버거" 담음
       → orderStore.orderList에 저장됨
  PaymentPage로 이동해도 장바구니 데이터가 유지됨
       → 같은 orderStore.orderList를 읽으니까!

만약 Store가 없다면?
  페이지를 이동할 때마다 데이터가 사라짐 😱
```

---

### 🔵 STEP 3: 결제수단 선택 (PaymentMethodPage.vue)

**사용자 행동:** 주문 페이지에서 "결제하기" → 카드, 간편결제 등 선택 + 쿠폰/포인트 적용

```javascript
// 화면이 열리면 결제수단 목록을 서버에서 가져옴
onMounted(async () => {
  const data = await api.getPaymentMethods()
  // GET http://localhost:3000/paymentMethods
  // 응답: { card: [...], easyPay: [...], other: [...] }
  paymentMethods.value = data
})

// 결제수단을 고르면
const selectPayment = (paymentId) => {
  selectedPayment.value = paymentId  // 선택한 결제수단 저장
}

// "결제하기" 버튼을 누르면
const handleConfirm = () => {
  orderStore.setPaymentMethod(selectedMethod)   // 스토어에 결제수단 저장
  orderStore.setTotalDiscount(totalDiscountPrice.value)  // 할인금액 저장
  router.push({ name: 'PaymentProcess' })       // 결제 처리 화면으로 이동
}
```

---

### 🔵 STEP 4: 결제 처리 (PaymentProcessView.vue)

**사용자 행동:** 카드를 넣거나 QR을 스캔하는 화면 (실제로는 시뮬레이션)

```javascript
// 화면이 열리면 자동으로 결제 처리 시작
onMounted(() => {
  startCountdown()       // 30초 카운트다운 시작
  simulatePayment()      // 결제 시뮬레이션 시작
})

// 결제가 성공하면 주문 데이터를 서버에 저장
const processPaymentSuccess = async () => {
  const orderNumbers = generateFullOrderNumber()  // 주문번호 생성
  
  const orderData = {
    orderNumber: orderNumbers.full,          // "ORD-20260210143025-1234"
    paymentMethod: paymentMethod.value,      // "카드결제"
    items: orderItems.value.map(item => ({   // 주문한 메뉴들
      id: item.id,
      name: item.name,
      price: item.price,
      quantity: item.quantity
    })),
    totalPrice: finalPrice.value,            // 최종 결제금액
    createdAt: new Date().toISOString(),     // 주문 시각
    status: 'completed'                       // 완료 상태
  }

  await api.createOrder(orderData)  // 서버에 주문 저장!
}
```

**api.createOrder가 하는 일:**
```javascript
async createOrder(orderData) {
  return axiosInstance.post('/orders', orderData)
  // POST = "새 데이터를 만들어줘"라는 의미의 HTTP 메서드
  // http://localhost:3000/orders 주소로
  // orderData를 보내서 db.json의 orders 배열에 추가
}
```

**이 순간의 전체 흐름:**
```
[결제 화면]                [api.js]              [JSON Server]         [db.json]
    │                        │                       │                    │
    │ "주문 저장해줘"          │                       │                    │
    │ api.createOrder(data)  │                       │                    │
    │───────────────────────>│                       │                    │
    │                        │ POST /orders          │                    │
    │                        │ body: {주문데이터}     │                    │
    │                        │──────────────────────>│                    │
    │                        │                       │ orders 배열에 추가  │
    │                        │                       │───────────────────>│
    │                        │                       │<───────────────────│
    │                        │ { id: 85, ... } 응답  │                    │
    │                        │<──────────────────────│                    │
    │ "저장 완료!"             │                       │                    │
    │<───────────────────────│                       │                    │
    │                        │                       │                    │
    │ 주문완료 모달 표시        │                       │                    │
    │ "주문번호: 1234"         │                       │                    │
```

---

### 🔵 STEP 5: 주문 완료 → 메인으로

```javascript
const handleGoHome = () => {
  orderStore.clearOrder()   // 장바구니 비우기 (다음 손님을 위해)
  router.push('/')          // 메인 화면으로 돌아가기
}
```

---

## 📌 5장. 데이터베이스(db.json) 구조 해설

```
db.json의 구조 = 8개의 테이블(배열)

┌─────────────────────────────────────────────────┐
│  users (1개)        - 관리자 계정                  │
│  예: { id:"1", username:"admin", password:"..." } │
├─────────────────────────────────────────────────┤
│  categories (6개)   - 메뉴 카테고리                │
│  예: { id:"pizza", name:{ ko:"피자", en:"Pizza" }} │
├─────────────────────────────────────────────────┤
│  menuItems (49개)   - 개별 메뉴                    │
│  예: { id:"1", name:{ko:"페퍼로니"}, price:15000,  │
│        category:"pizza", stock:50, image:"..." }  │
├─────────────────────────────────────────────────┤
│  combinations (5개) - 세트 메뉴                    │
│  예: { id:"combo_pizza_1", items:["1","11"],      │
│        discountPrice:500 }                        │
├─────────────────────────────────────────────────┤
│  paymentMethods     - 결제수단 (카드/간편결제/기타)  │
│  예: { card:[...], easyPay:[...], other:[...] }   │
├─────────────────────────────────────────────────┤
│  orders (84개)      - 주문 내역                    │
│  예: { orderNumber:"ORD-...", items:[...],        │
│        totalPrice:15000, status:"completed" }     │
├─────────────────────────────────────────────────┤
│  members (14개)     - 회원 정보                    │
│  예: { id:"1", phone:"010-1234-5678", points:500} │
├─────────────────────────────────────────────────┤
│  coupons (1개)      - 쿠폰                        │
│  예: { code:"WELCOME", amount:2000, used:false }  │
└─────────────────────────────────────────────────┘
```

---

## 📌 6장. HTTP 메서드 = "어떤 행동을 할지" 알려주는 약속

```
GET    = "데이터를 가져와줘"  (읽기)
POST   = "새 데이터를 만들어줘" (생성)
PUT    = "데이터를 통째로 바꿔줘" (전체 수정)
PATCH  = "데이터 일부만 바꿔줘" (부분 수정)
DELETE = "데이터를 삭제해줘"   (삭제)
```

**이 프로젝트에서의 실제 사용 예:**

| 상황 | HTTP 메서드 | URL | api.js 코드 |
|---|---|---|---|
| 메뉴 목록 보기 | GET | /menuItems | `axiosInstance.get('/menuItems')` |
| 주문하기 | POST | /orders | `axiosInstance.post('/orders', orderData)` |
| 메뉴 수정 (관리자) | PUT | /menuItems/1 | `axiosInstance.put('/menuItems/1', data)` |
| 재고만 변경 | PATCH | /menuItems/1 | `axiosInstance.patch('/menuItems/1', {stock:49})` |
| 메뉴 삭제 (관리자) | DELETE | /menuItems/1 | `axiosInstance.delete('/menuItems/1')` |

---

## 📌 7장. 핵심 파일별 코드 해석

### 7-1. axios.js — 서버 통신의 기본 설정

```javascript
import axios from 'axios'  // axios 라이브러리 불러오기

// axios 인스턴스 생성 = "이런 설정으로 통신하겠다"
const axiosInstance = axios.create({
  baseURL: 'http://localhost:3000',  
  // 모든 요청의 기본 주소
  // api.get('/menuItems') → 실제로는 http://localhost:3000/menuItems로 요청
  
  timeout: 10000,  
  // 10초(10000ms) 안에 응답이 없으면 에러 발생
  
  headers: { 'Content-Type': 'application/json' }
  // "나는 JSON 형식으로 데이터를 주고받겠다"
})

// 요청 인터셉터 = 요청이 나가기 전에 가로채서 로그 찍기
axiosInstance.interceptors.request.use(
  (config) => {
    console.log(`[API Request] ${config.method} ${config.url}`)
    // 개발 중에 "어떤 요청이 나갔는지" 확인용
    return config
  }
)

// 응답 인터셉터 = 응답이 돌아왔을 때 가로채서 처리
axiosInstance.interceptors.response.use(
  (response) => response.data,  
  // 성공: response 객체에서 data만 꺼내서 반환
  // 원래: { status:200, data:[{메뉴1},{메뉴2}], headers:{...} }
  // 처리후: [{메뉴1},{메뉴2}] ← 필요한 것만!
  
  (error) => {
    // 실패: 에러 정보를 정리해서 반환
    return Promise.reject({
      status: error.response?.status,   // 404, 500 등
      message: error.message
    })
  }
)
```

### 7-2. api.js — API 함수 모음집

```javascript
import axiosInstance from './axios'

export const api = {
  // === 메뉴 관련 ===
  
  async getCategories() {
    return axiosInstance.get('/categories')
    // GET http://localhost:3000/categories
    // 응답: [{ id:"pizza", name:{ko:"피자"} }, ...]
  },

  async getMenuItems() {
    return axiosInstance.get('/menuItems')
    // GET http://localhost:3000/menuItems
    // 응답: [{ id:"1", name:{ko:"페퍼로니"}, price:15000, ... }, ...]
  },

  async getMenuItemsByCategory(category) {
    return axiosInstance.get('/menuItems', {
      params: { category }
    })
    // GET http://localhost:3000/menuItems?category=pizza
    // params가 URL 뒤에 ?key=value 형태로 붙음
    // 응답: 피자 카테고리의 메뉴만 필터링되어 옴
  },

  // === 주문 관련 ===
  
  async createOrder(orderData) {
    return axiosInstance.post('/orders', orderData)
    // POST http://localhost:3000/orders
    // body에 orderData를 담아서 보냄
    // JSON Server가 db.json의 orders 배열에 새 항목 추가
  },

  // === 회원 관련 ===
  
  async getMemberByPhone(phone) {
    return axiosInstance.get('/members', {
      params: { phone }
    })
    // GET http://localhost:3000/members?phone=010-1234-5678
    // 해당 전화번호의 회원 정보를 찾아옴
  },

  // === 관리자 관련 ===
  
  async updateMenuItemStock(id, newStock) {
    return axiosInstance.patch(`/menuItems/${id}`, { stock: newStock })
    // PATCH http://localhost:3000/menuItems/1
    // body: { stock: 49 }
    // 해당 메뉴의 재고만 수정 (나머지는 그대로)
  }
}
```

### 7-3. orderStore.js — 주문 상태 관리

```javascript
import { defineStore } from 'pinia'

export const useOrderStore = defineStore('order', {
  // state = 저장할 데이터들
  state: () => ({
    orderList: [],              // 장바구니 목록
    selectedPaymentMethod: null, // 선택한 결제수단
    currentMember: null,         // 로그인한 회원 정보
    totalDiscount: 0,            // 총 할인금액
    usedPoints: 0,               // 사용한 포인트
  }),

  // getters = 저장된 데이터를 가공해서 반환 (계산된 값)
  getters: {
    calculatedTotalPrice: (state) => {
      // 장바구니의 모든 아이템 가격 합계
      return state.orderList.reduce((sum, item) => {
        return sum + (item.price * item.quantity)
      }, 0)
      // 예: [{price:5000, quantity:2}, {price:3000, quantity:1}]
      // → 5000*2 + 3000*1 = 13000
    }
  },

  // actions = 데이터를 변경하는 함수들
  actions: {
    addItem(item) { /* 장바구니에 추가 */ },
    removeItem(itemId) { /* 장바구니에서 제거 */ },
    updateQuantity(itemId, quantity) { /* 수량 변경 */ },
    setPaymentMethod(method) { /* 결제수단 설정 */ },
    clearOrder() {
      // 주문 완료 후 모든 데이터 초기화
      this.orderList = []
      this.selectedPaymentMethod = null
      this.currentMember = null
      this.totalDiscount = 0
      this.usedPoints = 0
    }
  }
})
```

### 7-4. router/index.js — 페이지 이동 규칙

```javascript
const routes = [
  {
    path: '/',                    // URL이 "/" 일 때 (루트)
    name: 'Main',                 // 이 라우트의 이름
    component: () => import('@/views/MainPage.vue')
    // → MainPage.vue 화면을 보여줘
  },
  {
    path: '/order',               // URL이 "/order" 일 때
    name: 'Order',
    component: () => import('@/views/OrderPage.vue')
    // → OrderPage.vue 화면을 보여줘
  },
  // ... 나머지도 같은 패턴
]

// 라우터 생성
const router = createRouter({
  history: createWebHistory(),    // 브라우저 히스토리 모드 (뒤로가기 지원)
  routes                          // 위에서 정의한 라우트 규칙 사용
})
```

---

## 📌 8장. 관리자 기능 플로우

```
관리자 로그인 → 대시보드 → 메뉴 관리 or 매출 통계

[AdminLoginPage]
    │ api.adminLogin({username, password})
    │ → GET /users?username=admin&password=password123
    │ → 일치하면 로그인 성공
    ▼
[AdminDashboard]
    ├──→ [AdminMenuManagement]
    │     - 메뉴 추가: api.createMenuItem() → POST /menuItems
    │     - 메뉴 수정: api.updateMenuItem() → PUT /menuItems/:id
    │     - 메뉴 삭제: api.deleteMenuItem() → DELETE /menuItems/:id
    │     - 재고 변경: api.updateMenuItemStock() → PATCH /menuItems/:id
    │
    └──→ [AdminSalesStats]
          - 매출 조회: api.getSalesStatistics() → GET /orders
          - 받아온 주문 데이터로 통계 계산
```

---

## 📌 9장. 자주 보이는 Vue.js 문법 해설

### ref와 reactive — 화면에 반응하는 데이터

```javascript
import { ref, computed } from 'vue'

const count = ref(0)        // ref = "이 데이터가 바뀌면 화면도 바뀌어야 해"
count.value = 5             // ref는 .value로 접근

const isLoading = ref(true) // 로딩 중인지 아닌지
isLoading.value = false     // 로딩 끝!
```

### computed — 자동으로 계산되는 값

```javascript
const totalPrice = computed(() => {
  return orderStore.calculatedTotalPrice
})
// orderStore의 데이터가 바뀔 때마다 자동으로 다시 계산됨
// 장바구니에 메뉴를 추가하면 → 총 가격이 자동으로 업데이트!
```

### onMounted — 화면이 열릴 때 실행

```javascript
onMounted(async () => {
  // 이 화면이 처음 열릴 때 한 번 실행
  const data = await api.getMenuItems()  // 서버에서 데이터 가져오기
  menuItems.value = data                  // 가져온 데이터를 화면에 표시
})
```

### v-for — 목록 반복 표시

```html
<!-- categories 배열의 각 항목을 버튼으로 표시 -->
<button v-for="cat in categories" :key="cat.id">
  {{ cat.name.ko }}
</button>
<!-- 결과: [피자] [햄버거] [음료] [샌드위치] [사이드] [디저트] -->
```

### v-if — 조건부 표시

```html
<div v-if="isLoading">로딩 중...</div>
<div v-else>메뉴 목록이 여기에 표시됨</div>
<!-- isLoading이 true면 "로딩 중..." 표시 -->
<!-- false면 메뉴 목록 표시 -->
```

### @click — 클릭 이벤트

```html
<button @click="addToCart(menu)">담기</button>
<!-- 이 버튼을 클릭하면 addToCart(menu) 함수가 실행됨 -->
```

---

## 📌 10장. 전체 플로우 한눈에 정리

```
[사용자 시나리오]

1. 🏠 메인 화면
   └─ "매장식사" 클릭 → router.push('/order')

2. 🍔 주문 화면
   ├─ 화면 열림 → onMounted에서 api.getMenuItems() 호출
   │              → GET /menuItems → db.json에서 메뉴 49개 가져옴
   ├─ 카테고리 클릭 → filteredMenuItems가 자동 필터링 (computed)
   ├─ 메뉴 클릭 → 상세 팝업(MenuInfoModal) 열림
   ├─ "담기" 클릭 → orderStore.addItem() → 장바구니에 추가
   └─ "결제하기" 클릭 → router.push('/payment-method')

3. 💳 결제수단 선택
   ├─ 화면 열림 → api.getPaymentMethods() 호출
   ├─ 카드/간편결제 선택
   ├─ (선택) 쿠폰 입력 → api.getCouponByCode() → 할인 적용
   ├─ (선택) 전화번호 입력 → api.getMemberByPhone() → 포인트 조회/사용
   └─ "결제하기" 클릭 → orderStore에 결제정보 저장
                       → router.push('/payment-process')

4. ⏳ 결제 처리
   ├─ 30초 카운트다운 시작
   ├─ 결제 시뮬레이션 (3초 후 성공)
   ├─ 성공 시:
   │   ├─ api.createOrder() → POST /orders → 주문 저장
   │   ├─ api.updateMenuItemStock() → PATCH /menuItems/:id → 재고 차감
   │   ├─ (회원이면) api.updateMember() → 포인트 적립
   │   └─ 주문완료 모달 표시 (주문번호 안내)
   └─ 실패 시 → router.push('/payment-fail')

5. ✅ 주문 완료
   └─ "처음으로" 클릭 → orderStore.clearOrder() → router.push('/')
                        장바구니 초기화           메인으로 돌아감
```

---

## 📌 부록: 공부 순서 추천

1. **먼저 이 문서를 2~3번 읽기** — 전체 흐름을 머리에 그리기
2. **router/index.js** — 어떤 페이지들이 있는지 파악
3. **db.json** — 어떤 데이터가 있는지 파악
4. **axios.js → api.js** — 서버와 어떻게 통신하는지 파악
5. **orderStore.js** — 데이터가 어떻게 공유되는지 파악
6. **MainPage.vue** — 가장 간단한 화면부터 코드 읽기
7. **OrderPage.vue** — 핵심 화면의 코드 읽기
8. **PaymentProcessView.vue** — 주문 저장 로직 이해하기

> 💡 **팁:** 코드를 읽을 때 "이 함수는 **누가** 호출하고, **무엇을** 하고, **결과는 어디로** 가는가?"를 항상 생각하세요!
